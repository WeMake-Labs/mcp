---
globs: *.ts,*.tsx
---

# TypeScript Development Standards

> **Strict TypeScript for maximum type safety**

## Quick Navigation

- üöÄ [Velocity Hub](mdc:.cursor/rules/velocity.mdc) - Start here
- üîß [Automation Suggestions](mdc:.cursor/rules/automation-suggestions.mdc) - Type improvements
- üß∞ [Bun-First Standards](mdc:.cursor/rules/bun-first.mdc) - Bun + TypeScript
- üèóÔ∏è [MCP Servers](mdc:.cursor/rules/mcp-servers.mdc) - Server type patterns
- üß™ [Testing](mdc:.cursor/rules/testing.mdc) - Type safety in tests

## Strict Mode Requirements

All TypeScript files MUST use strict mode. Verify [tsconfig.json](mdc:tsconfig.json) has:

## Import Organization Template

```typescript
// 1. Bun built-ins
import { describe, it, expect } from "bun:test";
import { Database } from "bun:sqlite";

// 2. External packages (alphabetically)
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { CallToolRequestSchema } from "@modelcontextprotocol/sdk/types.js";

// 3. Internal modules (relative imports, ordered by depth)
import { HelperClass } from "./helper.js";
import { UtilFunction } from "../utils/util.js";
import { ConfigType } from "../../config.js";

// 4. Type imports (grouped separately)
import type { Result, Config } from "./types.js";
import type { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
```

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictPropertyInitialization": true
  }
}
```

## Type Safety

### Complete Type Definitions

Always define explicit types for:

- Function parameters
- Function return types
- Class properties
- Object structures
- Complex data structures

### Interface-First Design

Use interfaces for data structures:

```typescript
interface DomainElement {
  id: string;
  name: string;
  type: "entity" | "attribute" | "relation" | "process";
  description: string;
}

interface AnalogicalMapping {
  sourceElement: string;
  targetElement: string;
  mappingStrength: number; // 0.0-1.0
  justification: string;
  limitations?: string[];
}
```

### Type Guards

Implement type guards for runtime validation:

```typescript
function isValidElementType(type: unknown): type is DomainElementType {
  return typeof type === "string" && allowedElementTypes.includes(type as DomainElementType);
}
```

## ES Modules Format

Use ES modules exclusively:

```typescript
// ‚úÖ Correct
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import type { Result } from "./types.js";
export default function createServer() {}

// ‚ùå Incorrect
const Server = require("@modelcontextprotocol/sdk/server");
module.exports = createServer;
```

## Import Standards

### Complete Imports

Import ALL methods, classes, and types used:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import type { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
```

### Import Organization

Order imports:

1. Bun built-ins (`bun:test`, `bun:sqlite`)
2. External packages (`@modelcontextprotocol/sdk`)
3. Internal modules (relative imports)
4. Type imports (group separately)

```typescript
import { describe, it, expect } from "bun:test";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";

import { MyModule } from "../src/myModule.js";
import { HelperClass } from "./helper.js";

import type { Result, Config } from "./types.js";
```

## No Any Types

Avoid `any` unless absolutely necessary. If required, document why:

```typescript
// ‚ùå Avoid
function process(data: any) {}

// ‚úÖ Preferred
function process(data: Record<string, unknown>) {}

// ‚úÖ When any is necessary (document)
/**
 * Handles dynamic MCP tool arguments.
 * Using any here because MCP protocol allows arbitrary JSON.
 */
function handleTool(args: any) {}
```

## Const Assertions

Use const assertions for literal types:

```typescript
const allowedStages = ["problem-definition", "options", "criteria", "evaluation"] as const;

type Stage = (typeof allowedStages)[number];
```

## File Extension Requirements

Always include `.js` extensions in imports (TypeScript transpiles to ES modules):

```typescript
// ‚úÖ Correct
import { helper } from "./helper.js";

// ‚ùå Incorrect
import { helper } from "./helper";
```

## Type Inference Examples

### When to Infer vs Explicit Types

```typescript
// ‚úÖ Infer simple types
const name = "John"; // string (inferred)
const count = 42; // number (inferred)
const active = true; // boolean (inferred)

// ‚úÖ Explicit for function returns
function processData(input: string): ProcessedData {
  return { value: input };
}

// ‚úÖ Infer from function return
const result = processData("data"); // ProcessedData (inferred)

// ‚úÖ Explicit for complex structures
const config: ServerConfig = {
  port: 8787,
  host: "localhost",
  timeout: 30000
};

// ‚ùå Redundant explicit type
const value: string = getValue(); // Type already known from getValue()

// ‚úÖ Better: Let TypeScript infer
const value = getValue();
```

### Generic Type Patterns

```typescript
// Generic function
function identity<T>(value: T): T {
  return value;
}

// Generic with constraints
function processItems<T extends { id: string }>(items: T[]): T[] {
  return items.filter((item) => item.id !== "");
}

// Generic class
class Registry<T> {
  private items: Map<string, T> = new Map();

  set(key: string, value: T): void {
    this.items.set(key, value);
  }

  get(key: string): T | undefined {
    return this.items.get(key);
  }
}
```

## Common Type Patterns Library

### Result Type Pattern

```typescript
type Result<T> = {
  content: Array<{ type: "text"; text: string }>;
  isError?: boolean;
  data?: T;
};

// Usage
function processOperation(input: unknown): Result<ProcessedData> {
  try {
    const data = process(input);
    return {
      content: [{ type: "text", text: "Success" }],
      data
    };
  } catch (error) {
    return {
      content: [{ type: "text", text: `Error: ${error.message}` }],
      isError: true
    };
  }
}
```

### Union Type Pattern

```typescript
type Stage = "planning" | "execution" | "evaluation" | "complete";

type Status = "pending" | "in_progress" | "completed" | "failed";

// With discriminated unions
type Operation =
  | { type: "create"; data: CreateData }
  | { type: "update"; id: string; data: UpdateData }
  | { type: "delete"; id: string };

function handleOperation(op: Operation): void {
  switch (op.type) {
    case "create":
      // op.data is CreateData
      break;
    case "update":
      // op.id and op.data are available
      break;
    case "delete":
      // op.id is available
      break;
  }
}
```

### Type Guard Pattern

```typescript
// Basic type guard
function isString(value: unknown): value is string {
  return typeof value === "string";
}

// Object type guard
interface User {
  id: string;
  name: string;
}

function isUser(value: unknown): value is User {
  return (
    typeof value === "object" &&
    value !== null &&
    "id" in value &&
    "name" in value &&
    typeof (value as User).id === "string" &&
    typeof (value as User).name === "string"
  );
}

// Usage
function processValue(value: unknown): void {
  if (isUser(value)) {
    // value is User here
    console.log(value.name);
  }
}
```

### Branded Type Pattern

```typescript
// Prevent mixing similar types
type UserId = string & { readonly brand: unique symbol };
type ProductId = string & { readonly brand: unique symbol };

function createUserId(id: string): UserId {
  return id as UserId;
}

function createProductId(id: string): ProductId {
  return id as ProductId;
}

// TypeScript prevents mixing
function getUser(id: UserId): User {
  /* ... */
}
function getProduct(id: ProductId): Product {
  /* ... */
}

const userId = createUserId("user-123");
const productId = createProductId("prod-456");

getUser(userId); // ‚úÖ Correct
getUser(productId); // ‚ùå Type error
```

### Readonly Pattern

```typescript
// Readonly properties
interface Config {
  readonly apiKey: string;
  readonly timeout: number;
}

// Readonly arrays
function processItems(items: readonly string[]): void {
  // items.push("new");  // ‚ùå Error: readonly
  console.log(items[0]); // ‚úÖ OK
}

// Deep readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: DeepReadonly<T[P]>;
};
```

### Utility Type Patterns

```typescript
// Pick specific properties
type UserPreview = Pick<User, "id" | "name">;

// Omit specific properties
type UserWithoutPassword = Omit<User, "password">;

// Partial for updates
type UserUpdate = Partial<User>;

// Required (opposite of Partial)
type RequiredUser = Required<UserUpdate>;

// Record for dictionaries
type UserMap = Record<string, User>;

// Extract union members
type SuccessStatus = Extract<Status, "completed" | "in_progress">;

// Exclude union members
type ErrorStatus = Exclude<Status, "completed" | "in_progress">;
```

## Examples

Reference implementations:

- [src/decision-framework/src/index.ts](mdc:src/decision-framework/src/index.ts)
- [src/memory/src/index.ts](mdc:src/memory/src/index.ts)
- [src/sequential-thinking/src/index.ts](mdc:src/sequential-thinking/src/index.ts)

## See Also

- [Velocity Hub](mdc:.cursor/rules/velocity.mdc) - Complete workflow guide
- [Bun-First Standards](mdc:.cursor/rules/bun-first.mdc) - Bun + TypeScript patterns
- [MCP Servers](mdc:.cursor/rules/mcp-servers.mdc) - Server type patterns
- [Testing](mdc:.cursor/rules/testing.mdc) - Type safety in tests
- [Automation Suggestions](mdc:.cursor/rules/automation-suggestions.mdc) - Type improvements
