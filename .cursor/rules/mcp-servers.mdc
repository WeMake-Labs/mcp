---
globs: src/*/src/index.ts
---

# MCP Server Implementation Patterns

## Standard MCP Server Structure

All MCP servers in this monorepo follow a consistent architecture pattern. Reference:
[src/decision-framework/src/index.ts](mdc:src/decision-framework/src/index.ts)

## Required Components

### 1. Validation Functions

Every server MUST implement input validation for all tool parameters:

```typescript
private validateInput(input: unknown): ValidatedDataType {
  if (typeof input !== "object" || input === null) {
    throw new Error("Invalid input: expected object");
  }

  const data = input as Record<string, unknown>;

  // Validate required fields with type guards
  if (typeof data.field !== "string") {
    throw new Error("Invalid input: field must be string");
  }

  // Validate enums
  if (!["option1", "option2"].includes(data.type as string)) {
    throw new Error(`Invalid type: ${data.type}`);
  }

  // Validate ranges
  if (typeof data.confidence !== "number" ||
      data.confidence < 0 || data.confidence > 1) {
    throw new Error("Invalid confidence: must be 0.0-1.0");
  }

  return data as ValidatedDataType;
}
```

### 2. Process Methods

Process methods return structured Result types:

```typescript
type Result = {
  content: Array<{ type: "text"; text: string }>;
  isError?: boolean;
};

public processOperation(input: unknown): Result {
  try {
    // 1. Validate input
    const validated = this.validateInput(input);

    // 2. Update state/registries
    this.updateRegistries(validated);

    // 3. Process operation
    const result = this.performOperation(validated);

    // 4. Generate visualization
    const visualization = this.visualize(validated);

    // 5. Return success result
    return {
      content: [{ type: "text", text: visualization }],
    };
  } catch (error) {
    // 6. Handle errors gracefully
    return {
      content: [{
        type: "text",
        text: `❌ Error: ${error instanceof Error ? error.message : String(error)}`
      }],
      isError: true,
    };
  }
}
```

### 3. History and Registry Tracking

Maintain state for audit trails and session continuity:

```typescript
class MyMCPServer {
  // History tracking
  private operationHistory: Record<string, OperationData[]> = {};

  // Registry tracking
  private entityRegistry: Record<string, Record<string, Entity>> = {};
  private relationRegistry: Record<string, Relation[]> = {};

  // Session management
  private sessionOrder: string[] = [];
  private readonly maxSessions = Number(process.env.MAX_SESSIONS ?? "100");

  private updateHistory(sessionId: string, data: OperationData): void {
    if (!this.operationHistory[sessionId]) {
      this.operationHistory[sessionId] = [];
      this.sessionOrder.push(sessionId);
    }

    this.operationHistory[sessionId].push(data);

    // Cleanup old sessions (GDPR compliance)
    while (this.sessionOrder.length > this.maxSessions) {
      const oldestSession = this.sessionOrder.shift()!;
      delete this.operationHistory[oldestSession];
    }
  }
}
```

### 4. Visualization Methods

Provide rich CLI output for human readability:

```typescript
private visualize(data: OperationData): string {
  const lines: string[] = [];

  lines.push("\n┌─────────────────────────────────────┐");
  lines.push("│  Operation Result                   │");
  lines.push("└─────────────────────────────────────┘\n");

  // Use colors for better readability
  lines.push(`Status: ${this.colorStatus(data.status)}`);
  lines.push(`Confidence: ${this.confidenceBar(data.confidence)}`);

  // Render data structures
  if (data.elements) {
    lines.push("\nElements:");
    for (const element of data.elements) {
      lines.push(`  • ${element.name} (${element.type})`);
    }
  }

  return lines.join("\n");
}

private colorStatus(status: string): string {
  const colors = {
    success: "\x1b[32m", // green
    pending: "\x1b[33m", // yellow
    error: "\x1b[31m",   // red
  };
  const reset = "\x1b[0m";
  const color = colors[status] || "";
  return `${color}${status}${reset}`;
}

private confidenceBar(confidence: number): string {
  const width = 20;
  const filled = Math.round(confidence * width);
  const bar = "█".repeat(filled) + "░".repeat(width - filled);
  return `${bar} ${(confidence * 100).toFixed(0)}%`;
}
```

### 5. Server Initialization

Standard server setup with proper shutdown:

```typescript
async function runServer() {
  const server = new Server(
    {
      name: "my-mcp-server",
      version: "1.0.0"
    },
    {
      capabilities: {
        tools: {}
      }
    }
  );

  const serverInstance = new MyMCPServer();

  // Tool handler
  server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;

    switch (name) {
      case "myTool":
        return serverInstance.processOperation(args);
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  });

  // List tools handler
  server.setRequestHandler(ListToolsRequestSchema, async () => ({
    tools: [
      {
        name: "myTool",
        description: "Description of what the tool does",
        inputSchema: {
          type: "object",
          properties: {
            field: { type: "string", description: "Field description" }
          },
          required: ["field"]
        }
      }
    ]
  }));

  // Shutdown handlers
  async function shutdown(exitCode: number = 0): Promise<void> {
    console.error("Shutting down gracefully...");

    try {
      // Close server connections
      if (server && typeof server.close === "function") {
        await server.close();
      }

      // Flush any pending database operations
      // Flush any pending logs
      // Close any open streams or connections

      console.error("Shutdown completed successfully");
    } catch (error) {
      console.error("Error during shutdown:", error);
      exitCode = 1;
    } finally {
      process.exit(exitCode);
    }
  }

  // Important: Don't use arrow functions for signal handlers
  process.on("SIGINT", () => {
    void shutdown(0);
  });

  process.on("SIGTERM", () => {
    void shutdown(0);
  });

  // Also handle uncaught errors
  process.on("uncaughtException", (error) => {
    console.error("Uncaught exception:", error);
    void shutdown(1);
  });

  process.on("unhandledRejection", (reason) => {
    console.error("Unhandled rejection:", reason);
    void shutdown(1);
  });

  // Start server
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

runServer().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
```

## Server Class Pattern

```typescript
class MyMCPServer {
  // 1. State tracking
  private history: Record<string, DataType[]> = {};
  private registry: Record<string, Entity> = {};
  private nextId = 1;

  // 2. Validation method
  private validateInput(input: unknown): ValidatedType {
    // Validation logic
  }

  // 3. Update methods
  private updateHistory(data: ValidatedType): void {}
  private updateRegistry(data: ValidatedType): void {}

  // 4. Visualization methods
  private visualize(data: ValidatedType): string {}

  // 5. Public process method
  public processOperation(input: unknown): Result {
    // Main processing logic
  }
}
```

## Reference Implementations

Study these for patterns:

- [src/decision-framework/src/index.ts](mdc:src/decision-framework/src/index.ts) - Complex multi-stage analysis
- [src/memory/src/index.ts](mdc:src/memory/src/index.ts) - CRUD operations with persistence
- [src/sequential-thinking/src/index.ts](mdc:src/sequential-thinking/src/index.ts) - Simple state tracking
- [src/collaborative-reasoning/src/index.ts](mdc:src/collaborative-reasoning/src/index.ts) - Multi-persona management
- [src/transaction-manager/src/server.ts](mdc:src/transaction-manager/src/server.ts) - Transaction handling
