I have analyzed the `narrative-planner` MCP server and the target Code Mode architecture.

**Analysis of Current State:**

- The current implementation in `src/narrative-planner/src/index.ts` is a single-file MCP server.
- The logic (`planNarrative`) and types (`NarrativeInput`) are mixed with MCP transport code.
- There is a mismatch between the simple implementation and the comprehensive README features. I will migrate the
  **current code's functionality** while establishing the architecture to support the full README features in the
  future.

**Migration Plan:**

1.  **Architecture Setup**:
    - Create directory structure: `src/core`, `src/codemode`, `src/mcp`.

2.  **Core Layer (`src/core/`)**:
    - **`types.ts`**: Extract `NarrativeInput` and define `NarrativeOutput`.
    - **`logic.ts`**: Move the `planNarrative` pure function here, removing any MCP dependencies.

3.  **Code Mode Layer (`src/codemode/`)**:
    - **`index.ts`**: Create a `NarrativePlanner` class.
    - Expose a typed method `plan(input: NarrativeInput): Promise<NarrativeOutput>`.
    - This becomes the primary programmatic API.

4.  **MCP Layer (`src/mcp/`)**:
    - **`tools.ts`**: Define the JSON Schema for the `narrativePlanner` tool.
    - **`server.ts`**: Implement the MCP server that wraps the `NarrativePlanner` class.

5.  **Entry Point (`src/index.ts`)**:
    - Update to export the `NarrativePlanner` class (Code Mode).
    - Conditionally run the MCP server if executed directly (e.g., via `bunx`).

6.  **Testing**:
    - Refactor `index.test.ts` to verify the `NarrativePlanner` class directly, ensuring logic works without the MCP
      transport overhead.

I will utilize the `mcp-code-architect` agent to execute this structural transformation precisely.
