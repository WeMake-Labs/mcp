# Analogical Reasoning Server Code Mode Migration Plan

I will execute a comprehensive migration of the `analogical-reasoning` MCP server to the Code Mode architecture,
strictly following the 3-layer pattern (Core, Code Mode, MCP) established in the documentation.

## 1. Architecture Design

The current implementation (`src/analogical-reasoning/src/index.ts`) mixes business logic, state management,
visualization, and MCP tool handling in a single file. The new architecture will separate these concerns:

### New Layered Structure

- **Core (`src/core/`)**: Pure domain logic and types.
  - `types.ts`: `DomainElement`, `AnalogicalMapping`, `AnalogicalReasoningData`, etc.
  - `manager.ts`: `AnalogicalReasoningManager` class handling state (history, registry), validation, and visualization
    logic.
- **Code Mode (`src/codemode/`)**: Public TypeScript API.
  - `index.ts`: `AnalogicalReasoning` class wrapping the Core manager, exposing a strictly-typed API for LLM
    consumption.
- **MCP Adapter (`src/mcp/`)**: Protocol Adapter.
  - `tools.ts`: Tool definitions (Zod Schemas and JSON Schemas).
  - `server.ts`: Server instantiation, request mapping, and error handling.

## 2. Migration Strategy

### Step 1: Directory Setup

- Create the following directories within `src/analogical-reasoning/src/`:
  - `core/`
  - `codemode/`
  - `mcp/`

### Step 2: Core Layer Implementation (`src/core/`)

- **Extract Types**: Move all interfaces (`DomainElement`, `AnalogicalMapping`, `AnalogicalReasoningData`) to
  `src/core/types.ts`.
- **Refactor Logic**: Move `AnalogicalReasoningServer` logic (renamed to `AnalogicalReasoningManager`) to
  `src/core/manager.ts`.
  - Extract `validateAnalogicalReasoningData`, `updateDomainRegistry`, `updateAnalogicalReasoning`, and
    `visualizeMapping`.
  - Ensure methods return typed objects, not MCP `CallToolResult` structures.
  - Remove MCP-specific dependencies (like `@modelcontextprotocol/sdk`).

### Step 3: Code Mode Layer Implementation (`src/codemode/`)

- **Create API Class**: Implement `AnalogicalReasoning` in `src/codemode/index.ts`.
- **Interface**:
  - `process(data: AnalogicalReasoningData): Promise<AnalogicalReasoningResult>`
  - Expose internal state accessors if necessary for programmatic use (e.g., `getHistory()`).
- **Role**: This class acts as the programmable entry point, initializing the Core manager.

### Step 4: MCP Layer Implementation (`src/mcp/`)

- **Tool Definitions**: Move `AnalogicalReasoningSchema` and tool metadata to `src/mcp/tools.ts`.
- **Server Logic**: Create `src/mcp/server.ts`.
  - Instantiate `AnalogicalReasoning` (Code Mode API).
  - Map the `analogicalReasoning` tool call to the Code Mode API.
  - Format the output into standard MCP `CallToolResult` objects.

### Step 5: Entry Point & Cleanup

- **Update Entry Point**: Modify `src/analogical-reasoning/src/index.ts` to:
  - Export the Code Mode API (`AnalogicalReasoning`).
  - Conditionally run the MCP server if executed directly (`import.meta.main`).
- **Dependencies**: Update `package.json` if necessary (likely unchanged).

## 3. Implementation Requirements

- **Backward Compatibility**: The external MCP tool interface (`analogicalReasoning` tool name and arguments) must
  remain identical.
- **Feature Parity**: All validation, visualization (Chalk output), and state tracking must work exactly as before.
- **Type Safety**: Ensure strict typing across all layers.

## 4. Testing & Validation

- **Unit Tests**: Refactor `src/analogical-reasoning/src/index.test.ts` to test the **Code Mode API** directly.
- **Verification**: Run the server locally to ensure it starts and responds to tool calls correctly.

I will use the `mcp-code-architect` agent to perform the code transformation where appropriate or manually implement the
changes if the agent is not suitable for this specific refactoring pattern.
