# Migration Plan: Metacognitive Monitoring to Code Mode Architecture

This plan outlines the migration of the `metacognitive-monitoring` MCP server from a monolithic implementation to a
modular, "Code Mode" ready architecture. This restructuring separates core business logic from the transport layer,
enabling both traditional MCP usage and direct TypeScript API access.

## 1. Architectural Restructuring

We will refactor the existing single-file implementation into a modular domain-driven structure:

```text
src/metacognitive-monitoring/
├── src/
│   ├── core/                  # Core Domain Logic (Transport Agnostic)
│   │   ├── types.ts           # Shared TypeScript interfaces (Domain models)
│   │   ├── analyzer.ts        # Business logic, validation, and state management
│   │   └── formatter.ts       # Visualization and logging logic (moved from main file)
│   ├── mcp/                   # Traditional MCP Layer
│   │   ├── server.ts          # MCP Server instantiation and configuration
│   │   └── tools.ts           # Tool definitions and schema mapping
│   ├── codemode/              # New Code Mode Layer
│   │   ├── index.ts           # TypeScript API exports
│   │   └── wrapper.ts         # Code Mode specific bindings/adapters
│   └── index.ts               # Main entry point (Backward compatibility)
├── tests/
│   ├── core/                  # Unit tests for business logic
│   ├── mcp/                   # Integration tests for MCP server
│   └── codemode/              # API tests for Code Mode usage
└── package.json               # Updated exports
```

## 2. Implementation Steps

### Phase 1: Core Extraction (Refactoring)

1.  **Extract Interfaces**: Move `MetacognitiveMonitoringData`, `KnowledgeAssessment`, etc., to `src/core/types.ts`.
2.  **Isolate Business Logic**: Create `MetacognitiveAnalyzer` in `src/core/analyzer.ts`.
    - Move validation logic (`validateMetacognitiveMonitoringData`) here.
    - Move state management (`monitoringHistory`, `knowledgeInventory`) here.
    - Ensure this class has **zero dependencies** on `@modelcontextprotocol/sdk`.
3.  **Extract Formatting**: Move `chalk` based logging logic to `src/core/formatter.ts`.

### Phase 2: MCP Layer Reconstruction

1.  **Rebuild Server**: Create `src/mcp/server.ts` that imports `MetacognitiveAnalyzer`.
2.  **Define Tools**: Move tool definitions to `src/mcp/tools.ts`, referencing the core types.
3.  **Backward Compatibility**: Ensure `bun run start` still launches the server identically to before.

### Phase 3: Code Mode Implementation

1.  **Create API Layer**: Implement `src/codemode/index.ts` exporting a typed API surface.
    - `export class MetacognitiveAPI { ... }`
2.  **Add Type Definitions**: Ensure full JSDoc comments are preserved/enhanced for LLM readability.

### Phase 4: Testing & Verification

1.  **Unit Tests**: Port existing validation tests to `tests/core/`.
2.  **Coverage**: Add new tests for the separated Formatter and Analyzer classes to reach >95% coverage.
3.  **Integration**: Verify the MCP server still responds correctly to JSON-RPC calls.
4.  **CI Validation**: Run the full project test suite.

## 3. Migration Safety & Rollback

- **Backup**: Create a backup of the current `src/` directory to `src_backup/` before starting.
- **Verification**: Run `bun test` after every phase.
- **Rollback Plan**:
  1.  If migration fails or tests regress significantly:
  2.  Delete the new `src/` directory.
  3.  Restore `src_backup/` to `src/`.
  4.  Revert `package.json` changes.

## 4. Deliverables

1.  Refactored codebase in `src/metacognitive-monitoring/`.
2.  Updated `README.md` with "Code Mode" usage instructions.
3.  Migration log file detailing changes.
4.  Test coverage report showing >95%.

I am ready to execute this plan. Please confirm.
