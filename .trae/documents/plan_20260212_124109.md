# Memory Server Code Mode Migration Plan

I will execute a comprehensive migration of the `memory` MCP server to the Code Mode architecture, strictly following
the 3-layer pattern (Core, Code Mode, MCP) and migration guidelines.

## 1. Architecture Design

The current implementation (`src/memory/src/index.ts`) mixes business logic, file persistence, and MCP tool handling in
a single file. The new architecture will separate these concerns:

### New Layered Structure

- **Core (`src/core/`)**: Pure domain logic and types.
  - `types.ts`: `Entity`, `Relation`, `KnowledgeGraph` interfaces.
  - `manager.ts`: `KnowledgeGraphManager` class handling file I/O and graph operations.
- **Code Mode (`src/codemode/`)**: Public TypeScript API.
  - `index.ts`: `MemoryGraph` class wrapping the Core manager, exposing a strictly-typed API for LLM consumption.
- **MCP Adapter (`src/mcp/`)**: Protocol Adapter.
  - `tools.ts`: Tool definitions (JSON Schemas).
  - `server.ts`: Server instantiation, request mapping, and error handling.

## 2. Migration Strategy

### Step 1: Directory Setup

- Create the following directories within `src/memory/src/`:
  - `core/`
  - `codemode/`
  - `mcp/`

### Step 2: Core Layer Implementation (`src/core/`)

- **Extract Types**: Move `Entity`, `Relation`, `KnowledgeGraph` interfaces to `src/core/types.ts`.
- **Refactor Logic**: Move `KnowledgeGraphManager` to `src/core/manager.ts`.
  - **Improvement**: Refactor the class to accept `memoryFilePath` in the constructor instead of relying on a global
    variable.
  - Ensure all methods (`createEntities`, `readGraph`, etc.) remain stateless regarding the request context.
  - Ensure strictly typed return values (no MCP `CallToolResult` dependencies).

### Step 3: Code Mode Layer Implementation (`src/codemode/`)

- **Create API Class**: Implement `MemoryGraph` in `src/codemode/index.ts`.
- **Interface**:
  - `createEntities(entities: Entity[]): Promise<Entity[]>`
  - `createRelations(relations: Relation[]): Promise<Relation[]>`
  - `addObservations(args: AddObservationArgs[]): Promise<ObservationResult[]>`
  - `readGraph(): Promise<KnowledgeGraph>`
  - ...and so on for all existing capabilities.
- **Role**: This class acts as the programmable entry point, handling initialization of the Core manager.

### Step 4: MCP Layer Implementation (`src/mcp/`)

- **Tool Definitions**: Extract tool JSON schemas into `src/mcp/tools.ts`.
- **Server Logic**: Create `src/mcp/server.ts`.
  - Parse environment variables (e.g., `MEMORY_FILE_PATH`).
  - Instantiate `MemoryGraph`.
  - Map MCP tool calls (e.g., `create_entities`) to `MemoryGraph` methods.
  - Format return values into standard MCP `CallToolResult` objects.

### Step 5: Entry Point & Cleanup

- **Update Entry Point**: Modify `src/memory/src/index.ts` (or `src/index.ts`) to:
  - Export the Code Mode API (`MemoryGraph`).
  - Conditionally run the MCP server if executed directly.
- **Dependencies**: Ensure `package.json` reflects any changes (unlikely to change much).

## 3. Implementation Requirements

- **Backward Compatibility**: The external MCP tool interface (names and arguments) must remain identical.
- **Configuration**: `MEMORY_FILE_PATH` support must be preserved.
- **Data Persistence**: Ensure the JSONL file format and handling logic remains consistent to avoid data loss.

## 4. Testing & Validation

- **Unit Tests**: Refactor `src/memory/src/index.test.ts` to test the **Code Mode API** directly, bypassing the MCP
  layer for logic verification.
- **Integration Tests**: Verify the MCP server works via stdio using a test script or manual verification.
- **Rollback Plan**: Backup original `index.ts` before modification. If migration fails, restore the single-file
  implementation.

## 5. Documentation

- Update `src/memory/README.md` to document the new Code Mode API usage (e.g., how to import and use `MemoryGraph`
  programmatically).
